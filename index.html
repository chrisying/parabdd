<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">ul.lst-kix_yp1yjv11jjvt-6{list-style-type:none}ul.lst-kix_yp1yjv11jjvt-7{list-style-type:none}ul.lst-kix_yp1yjv11jjvt-4{list-style-type:none}.lst-kix_yp1yjv11jjvt-2>li:before{content:"-  "}.lst-kix_yp1yjv11jjvt-4>li:before{content:"-  "}ul.lst-kix_yp1yjv11jjvt-5{list-style-type:none}ul.lst-kix_yp1yjv11jjvt-2{list-style-type:none}ul.lst-kix_yp1yjv11jjvt-3{list-style-type:none}ul.lst-kix_yp1yjv11jjvt-0{list-style-type:none}ul.lst-kix_yp1yjv11jjvt-1{list-style-type:none}.lst-kix_yp1yjv11jjvt-3>li:before{content:"-  "}.lst-kix_yp1yjv11jjvt-7>li:before{content:"-  "}.lst-kix_yp1yjv11jjvt-0>li:before{content:"-  "}.lst-kix_yp1yjv11jjvt-8>li:before{content:"-  "}.lst-kix_yp1yjv11jjvt-1>li:before{content:"-  "}.lst-kix_yp1yjv11jjvt-6>li:before{content:"-  "}ul.lst-kix_yp1yjv11jjvt-8{list-style-type:none}.lst-kix_yp1yjv11jjvt-5>li:before{content:"-  "}ol{margin:0;padding:0}table td,table th{padding:0}.c4{background-color:#ffffff;max-width:468pt;padding:72pt 72pt 72pt 72pt}.c6{padding:0;margin:0}.c7{color:inherit;text-decoration:inherit}.c0{orphans:2;widows:2}.c5{color:#1155cc;text-decoration:underline}.c1{margin-left:36pt;padding-left:0pt}.c2{height:11pt}.c3{page-break-after:avoid}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c4"><p class="c0 c3 title" id="h.jekux7yssmy"><span>Parallel BDDs for Efficient Model Checking on the Xeon Phi</span></p><p class="c0 c3 subtitle" id="h.biq2zgcktp3s"><span>Matt Bryant and Chris Ying</span></p><h1 class="c0 c3" id="h.mhsatly0ayci"><span>Summary</span></h1><p class="c0"><span>Binary Decision Diagrams (BDDs) are commonly used in industry for model checking, such as in computer-aided design. We will implement a parallel BDD library that is optimized for many-core machines, such as the Xeon Phi.</span></p><h1 class="c0 c3" id="h.txxjyxfvoo3i"><span>Background</span></h1><p class="c0"><span>A BDD is a data structure used to represent boolean functions in a graph structure. BDD&#39;s can be used to model state transformations and evaluate the validity of systems. For example, one use case for BDD&#39;s is verifying the correctness of concurrent programs to ensure that multiple threads cannot access a critical section at the same time. In general, evaluation for model checking involves taking an initial BDD and a set of transition rules and computing the &quot;reachibility&quot; of the states in an iterative fashion.</span></p><p class="c0 c2"><span></span></p><p class="c0"><span>Though there are existing existing packages that perform BDD evaluation, none of them utilize modern multi-core processors like the Xeon Phi. In order to take advantage of multi-core processors, we need to be able to represent a BDD in a structure that multiple processors can access and modify at one. In addition, we need to memoize the computation of different parts of the BDD to prevent duplicate work. These two goals can be met with a lockfree global hash, which reduces synchronization and communication costs compared to a lock-based data structure.</span></p><h1 class="c0 c3" id="h.kjnkexo0gbv5"><span>The Challenge</span></h1><p class="c0"><span>One of the big conceptual challenges for this problem is that neither of us have worked with BDD&#39;s before. To fully understand the project, we will first need to explore the literature covering BDD&#39;s and the algorithms that deal with evaluating them. Since there are no publicly available parallel BDD evaluators yet, we will have to base our code on research papers which have not actually implemented the any realistic system in practice.</span></p><p class="c0 c2"><span></span></p><p class="c0"><span>Another big challenge is getting a fast and correct lockfree hash table. Though there are numerous papers and existing lockfree hash tables, we will likely have to implement our own version to support memory management, resizing, and probing in the way that we need. Specifically, we will need to write our own garbage collection to delete unused BDD nodes to keep the memory footprint at a reasonable size.</span></p><h1 class="c0 c3" id="h.c49cr3utd4l9"><span>Resources</span></h1><p class="c0"><span>We will utilize the Xeon Phi&rsquo;s on the latedays cluster.</span></p><p class="c0"><span>We will be starting from scratch, though there is a similar sequential library that is commonly used, &lt;a href=&rdquo;</span><span class="c5"><a class="c7" href="https://www.google.com/url?q=http://buddy.sourceforge.net/manual/main.html&amp;sa=D&amp;ust=1459566689291000&amp;usg=AFQjCNHfeGYzrlGgnXIfHc5-1AHOBmJlvA">http://buddy.sourceforge.net/manual/main.html</a></span><span>&rdquo;&gt;BuDDy&lt;/a&gt;.</span></p><p class="c0"><span>Our main literary resource will be &lt;a href=&rdquo;http://essay.utwente.nl/61650/1/thesis_Tom_van_Dijk.pdf&rdquo;&gt;Tom van Dijk&rsquo;s master&rsquo;s thesis&lt;/a&gt;, which presents a survey over the field of BDDs and provides proofs of several BDD operations.</span></p><p class="c0"><span>We would greatly benefit from access to a Knight&rsquo;s Landing Xeon Phi, but Professor Kayvon has told us this is impossible.</span></p><h1 class="c0 c3" id="h.s30zsl3o8q5w"><span>Goals and Deliverables</span></h1><p class="c0"><span>Our project will have two main deliverables which are largely independent:</span></p><ul class="c6 lst-kix_yp1yjv11jjvt-0 start"><li class="c0 c1"><span>First, we will have a standalone lockfree hash table implementation that supports memory management and resizing. This hash table will be benchmarked against existing locking and lockfree hash tables to ensure that our implementation is competitive with the state-of-the-art systems that exist.</span></li><li class="c0 c1"><span>Second, we will have an system that takes an initial state (modeled as a BDD) and a transition relation (as a BDD) as input and evaluates the reachibility of the state. Users will be able to interface with our system through an API that allows them to manually construct the BDD&#39;s that they wish to evaluate. In order to demo this part of the project, we will write a few example programs that will use BDD&#39;s to check the correctness of some system (for example: deadlock checking, or n-Queens problem).</span></li></ul><h1 class="c0 c3" id="h.4i4stgk6sshb"><span>Platform Choice</span></h1><p class="c0"><span>To properly demonstrate the parallelism and scalability of our library, which we intend to be able to handle BDDs with millions of nodes, we need to use hardware with many cores. &nbsp;The Xeon Phi provides a machine with 60 cores, along with a simple target to optimize for.</span></p><p class="c0"><span>This library will be implemented in C++14, as this is a reasonable language that people seem to like, and will be targeted at all standards-compliant operating systems, with preference given to Linux if we run into issues.</span></p><h1 class="c0 c3" id="h.9czw6y3vuofn"><span>Schedule</span></h1><p class="c0"><span>Week 1:</span></p><p class="c0"><span>Implement a sequential implementation of BDDs and ensure correctness.</span></p><p class="c0 c2"><span></span></p><p class="c0"><span>Week 2:</span></p><p class="c0"><span>Implement a parallel hash table for memoization and reduction purposes.</span></p><p class="c0 c2"><span></span></p><p class="c0"><span>Week 3:</span></p><p class="c0"><span>Modify the sequential implementation to be parallel. &nbsp;Debug until correct.</span></p><p class="c0 c2"><span></span></p><p class="c0"><span>Week 4:</span></p><p class="c0"><span>Performance tweaking.</span></p><p class="c0 c2"><span></span></p><p class="c0"><span>Week 5:</span></p><p class="c0"><span>Creation of cool looking test cases/demo.</span></p></body></html>