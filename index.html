<!DOCTYPE html>
<html>
	<head>
		<meta charset='utf-8'>
		<meta http-equiv="X-UA-Compatible" content="chrome=1">
		<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
		<link href='https://fonts.googleapis.com/css?family=Architects+Daughter' rel='stylesheet' type='text/css'>
		<link href='https://fonts.googleapis.com/css?family=Roboto' rel='stylesheet' type='text/css'>
		<link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
		<link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
		<link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print">
		<title>ParaBDD</title>
	</head>

	<body>
		<header>
			<div class="inner">
				<h1>ParaBDD</h1>
				<h2>Parallel Binary Decision Diagrams for Efficient Model Checking</h2>
				<h2>Chris Ying and Matt Bryant</h2>
				<a href="https://github.com/chrisying/parabdd" class="button"><small>View project on</small> GitHub</a>
			</div>
		</header>

		<div id="content-wrapper">
			<div class="inner clearfix">
				<section id="main-content">
					<h2>
						<a id="summary" class="anchor" href="#summary" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Summary</h2>

					<p>We created a parallel binary decision diagram (BDD) library using CilkPlus which allows us to find and count satisfying assignments to arbitrary boolean expressions efficiently. Our implementation achieves ___ speedup on ___ cores and beats an existing BDD library by over an order of magnitude.</p>

					<h2>
						<a id="background" class="anchor" href="#background" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Background</h2>

					<p>BDD's are an efficient data structure for representing arbitrary boolean expressions. Using canonicity rules and duplicate detection, we can represent an exponentially growing data structure in manageable memory. The result is a directed acyclic graph that looks like the following graph generated by our library for 5-queens.</p>

					<p><img src="http://www.chrisying.net/parabdd/images/nqueens.dot.svg" alt=""></p>

					<p>The user interactions with the library by declaring elementary BDD's and composing them together with standard boolean operations. The library is as simple as:</p>

					<pre><code><span style="color:#FF8C00">Bdd</span><span style="color:#1e1e1e"> a(<span style="color:#E20">1</span>);</span>
<span style="color:#FF8C00">Bdd</span><span style="color:#1e1e1e"> b(<span style="color:#E20">2</span>);</span>
<span style="color:#FF8C00">Bdd</span><span style="color:#1e1e1e"> c = a &amp; b;</span>

// Gives one satisfying assignment to the expression (returns &lt;1:true, 2:true&gt;)
<span style="color:#1E1E1E">unordered_map&lt;<span style="color:#EE7600">Var</span>, <span style="color: #EE7600">bool</span>&gt; map = c.one_sat();</span>

// Count the number of satisfying assignments (returns 1 for a &amp; b)
<span style="color:#1E1E1E"><span style="color:#EE7600">int</span> num = c.count_sat();</span>
					</code></pre>

					<p>The following mechanisms are required to generate the BDD:</p>

					<ul>
						<li>An efficient and multi-threaded hash table for storing BDD's so that each unique "subgraph" is only ever generated once.</li>
						<li>Another hash table for caching the results of intermediate operations for constructing the BDD and doing other operations.</li>
						<li>A set of logically consistent "rewrite" rules that allows us to enforce a canonical form on the structure of BDD's.</li>
					</ul>

					<p>Most existing BDD libraries, including the well-know libraries <a href="http://buddy.sourceforge.net/manual/main.html">BuDDy</a> and <a href="http://vlsi.colorado.edu/%7Efabio/CUDD/cudd.pdf">CUDD</a>, have efficient single-threaded implementations for the first two points and have a decent set of canonicity rules. However, according to the <a href="http://essay.utwente.nl/61650/1/thesis_Tom_van_Dijk.pdf">literature</a> that we reviewed, there are huge opportunities for improvement on all three fronts:</p>

					<ul>
						<li>We can use a lock-free or fine-grained locking hash table to allow multi-threaded access to the uniques table and the cache.</li>
						<li>We can use fork-join parallelism to speed up the construction and count SAT operations since they are mostly recursive "divide-and-conquer"-like algorithms.</li>
						<li>We can decrease the number of unique elements by utilizing complement edges and it's associated rewrite rules.</li>
					</ul>

					<h2>
						<a id="approach" class="anchor" href="#approach" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Approach</h2>

					<p>We will first discuss the hash table we implemented. We initially wanted to implement a lock-free hash table to store unique BDD's as well as the cache. However, it turns out that the keys to our hash table would have be be at least 16 bytes long, which means we would have to use double-length compare-and-swap (CMPXCHG16B), which is unsupported by the Xeon Phi, which immediately killed that option.</p>

					<p>Instead, we created a fine-grained open-addressing hash table. Our hash table takes an arbitrary length key and hashes it using the <a href="https://github.com/aappleby/smhasher">MurmurHash3</a> hashing scheme. After hashing the key to a bucket, we linearly probe for an open bin and acquire a lock on that bin before inserting the element. We initialize the hash table to a size that will ensure a low number of collisions.</p>

					<p>Next, we will discuss the fork-join parallelism. One of the key operations for constructing a BDD is an "if-then-else" (ITE) expansion, which is used for composing any two BDD's together. ITE requires recursively traversing through the BDD graph, calling ITE independently twice per run. Since the two recursive calls are independent, they can be called in parallel. However, since we don't have enough cores to run all ITE calls in parallel together, we have to implement some sort of work queue in order to efficiently utilize all the cores as well as respect the execution order (the two recursive ITE calls have to finish before returning).</p>

					<p>This model of computation is known as fork-join parallelism, which forks to spawn jobs that should be added to a work queue and joins to combine the results from forked jobs. Unfortunately, C++ semantics make it hard to implement arbitrary continuations (required for general fork-join) without compiler support. We choose to use <a href="https://www.cilkplus.org/">CilkPlus</a>, which provides parallel keywords for fork-join semantics.</p>

					<p>Lastly, we will discuss the additional opportunities for canonicity rules. The BuDDy library represents BDD's without complemented edges. However, according to the literature, we can effectively represent a BDD and its complement with the same BDD by implementing a complex set of rewrite and canonicity rules. To do this with minimal memory footprint, we used a bit hack in order to encode the complement state in the existing pointer itself.</p>

					<h2>
						<a id="results" class="anchor" href="#results" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Results</h2>

					<p>To benchmark our library, we implemented a naive N-queens algorithm and compared runtimes with BuDDy and our library using varying amounts of cores on the GHC machines.  We haven't finished analysis yet, but we present a quick survey of the results below.  In particular, we note a greater than 10x speedup over BuDDy when utilizing the entire machine on large BDDs.</p>

					<table>
						<tbody>
							<tr>
								<td></td>
								<td colspan=4>Walltime (seconds)</td>
							</tr>
							<tr>
								<td>N</td>
								<td>Multicore ParaBDD</td>
								<td>BuDDy</td>
								<td>1-core ParaBDD</td>
								<td>4-core ParaBDD</td>
							</tr>
							<tr>
								<td>6</td>
								<td>1.80</td>
								<td>0.01</td>
								<td>1.59</td>
								<td>1.88</td>
							</tr>
							<tr>
								<td>7</td>
								<td>3.33</td>
								<td>0.01</td>
								<td>3.01</td>
								<td>3.86</td>
							</tr>
							<tr>
								<td>8</td>
								<td>3.19</td>
								<td>0.02</td>
								<td>3.63</td>
								<td>4.67</td>
							</tr>
							<tr>
								<td>9</td>
								<td>4.01</td>
								<td>0.06</td>
								<td>3.96</td>
								<td>4.76</td>
							</tr>
							<tr>
								<td>10</td>
								<td>4.31</td>
								<td>0.29</td>
								<td>4.62</td>
								<td>5.90</td>
							</tr>
							<tr>
								<td>11</td>
								<td>7.14</td>
								<td>3.75</td>
								<td>9.30</td>
								<td>11.87</td>
							</tr>
							<tr>
								<td>12</td>
								<td>14.69</td>
								<td>50.71</td>
								<td>39.39</td>
								<td>43.30</td>
							</tr>
							<tr>
								<td>13</td>
								<td>63.12</td>
								<td>1060.59</td>
								<td>213.20</td>
								<td>173.45</td>
							</tr>
							<tr>
								<td>14</td>
								<td>356.78</td>
								<td>&gt;3600</td>
								<td>1485.84</td>
								<td>1239.5</td>
							</tr>
						</tbody>
					</table>

					<h2>
						<a id="future-work" class="anchor" href="#future-work" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Future Work</h2>

					<p>There are many additional optimizations that exist in current libraries that were not possible to implement in the scope of this project. Primarilty, the key optimizations are:</p>

					<ul>
						<li>Reordering rules to optimize the order that variables are constructed to minimize the BDD complexity</li>
						<li>Garbage collection for unused BDD's to reduce the peak memory footprint</li>
					</ul>

					<p>In addition, in the process of designing the library, we encountered a few areas for improvement:</p>

					<ul>
						<li>Fork-join rescheduling in order to eliminate the rare chance of duplicated work (e.g. if another worker is currently doing a job, that job will never be done by another worker)</li>
						<li>Granularity control in order to reduce the overhead of the fork-join parallelism (e.g. with a system like PASL)</li>
					</ul>

					<h2>
						<a id="references" class="anchor" href="#references" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>References</h2>

					<ul>
						<li>Van Dijk, Tom, Alfons Laarman, and Jaco Van De Pol. "Multi-core BDD operations for symbolic reachability." Electronic Notes in Theoretical Computer Science 296 (2013): 127-143.</li>
						<li>Somenzi, Fabio. "CUDD: CU Decision Diagram Package Release 3.0. 0." (2015).</li>
					</ul>

					<h2>
						<a id="list-of-work" class="anchor" href="#list-of-work" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>List of Work</h2>

					<p>Equal work was performed by both project members.</p>
				</section>
			</div>
		</div>


	</body>
</html>
